## 2.硬件同步
### 2.1 [Test And Set](TestAndSetLock.java)
在实现***TestAndSet***锁时，通过创建10个线程测试互斥效果，发现如下现象：

**线程不是从 1-10 依次进入和离开临界区**，经学习原因如下：

这是因为在多线程环境中，线程的调度是**由操作系统的线程调度器控制**的，而不是由程序员显式地控制。
在 ``TestAndSet`` 方法中，每个线程首先尝试获取锁，若锁被占用，则会自旋等待。
线程获取锁后进入临界区，然后在执行完操作后释放锁。

线程调度是非确定性的，操作系统可能会在任何时间中断一个线程并调度另一个线程，
这意味着线程进入临界区的顺序是随机的，而不是依次 1 到 10。
所以，线程的进入顺序是乱序的，而不是按编号顺序（如线程-0、线程-1、线程-2 …）执行。

**另外**：这种锁叫做**自旋锁**，通过``while``循环进行使用

### 2.2 [Swap Lock](SwapLock.java)
首先，认识一下什么叫**原子性**

#### 原子性
* **即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。**
* 例子：生产者消费者问题中的***counter++***

在实现时，***Swap***方法请见方式一和方式二


```java
// 方式一
private void Swap(AtomicBoolean key) {
    boolean temp = lock.get();  // (1) 读取 lock 的值
    lock.set(key.get());        // (2) 设置 lock = key
    key.set(temp);              // (3) 设置 key = 原 lock 的值
}
```

```java
// 方式二
private void Swap(AtomicBoolean key) {
    boolean temp = lock.getAndSet(key.get());
    key.set(temp);
}
```
虽然看起来两者功能类似，但实际上，方式一并不能实现***SwapLock***，原因如下：

不是原子操作：虽然 ``get()`` 和 ``set()`` 本身是原子的，但 整个 Swap 操作不是原子的。

* 如果线程 A 执行到 (1) 读取 ``lock`` 的值后，线程 B 可能同时修改 ``lock``，导致 (2) 和 (3) 的结果不正确。
* 这样可能导致多个线程同时进入临界区，破坏锁的互斥性。

解决方案即方式二：
``AtomicBoolean.getAndSet(newValue)`` 是一个 原子操作，它会：

1. 返回 AtomicBoolean 的旧值（相当于 ``get()``）。
2. 同时设置新值（相当于 ``set(newValue)``）。
3. 整个过程是**原子**的，不会被其他线程打断。



